package com.tscloud.address.ui.utils;

import com.tscloud.address.domain.entity.AddressResult;
import org.apache.commons.io.IOUtils;
import org.geotools.data.shapefile.ShapefileDataStore;
import org.geotools.feature.FeatureCollection;
import org.geotools.feature.FeatureIterator;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.AttributeDescriptor;
import org.opengis.feature.type.GeometryDescriptor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

/**
 * @author Leighton
 * @create 2018-11-16.
 */
public class ShapeUtils {
    private static Logger logger = LoggerFactory.getLogger(ShapeUtils.class);
    private static final String SHAPE_TYPE_POI="Point";
    private static final int ATTUIBUE_NUM=5;//属性个个数

//    private static final String []property=new String[]{"name","address","adcode","type","level"};
//    private static final List<String> property=Arrays.asList("name","address","adcode","type","level");
    /**
     * 分析shape文件获取里面的数据
     * @param file
     */
    public static Object [] analyzeShape(File file,List<String> parame){
        logger.info("开始处理shape文件");
        ShapefileDataStore dataStore = null;
        FeatureIterator<SimpleFeature> features=null;
//        String  result=null;
        List<AddressResult> addressResults=new ArrayList<>();
        try {
            dataStore = new ShapefileDataStore(file.toURI().toURL());
            dataStore.setCharset(Charset.forName(codeString(file)));

            //判断当前shap文件是否存储是poi数据
            if(!dataStore.getFeatureSource().getSchema().getGeometryDescriptor().getType().getName().toString().equals(SHAPE_TYPE_POI)){
                throw  new UnsupportedOperationException("这个shape文件中的数据不符合要求");
            }
            List<String> attrMatch=new ArrayList<>();
            //获取shape文件属性
            List<AttributeDescriptor> attributeDescriptors= dataStore.getSchema().getAttributeDescriptors();
            attributeDescriptors.forEach(action->{
                //过滤掉空间属性
                if (!(action instanceof GeometryDescriptor)){
                    action.getName().toString();
                }
            });
           /* if (attrMatch.size()<5){
                throw new UnsupportedOperationException("这个shap文件中的数据不符合要求");
            }*/
            FeatureCollection<SimpleFeatureType, SimpleFeature> collection =  dataStore.getFeatureSource().getFeatures();
            features = collection.features();
            Object []obj=collection.toArray();//提取所有的数据

            logger.info("shape文件解析完成,开始处理数据");
            return obj;
        } catch (Exception e) {
//            e.printStackTrace();
            logger.error(e.getMessage());
        }finally {
            if (features!=null){
             features.close();
            }
        }

        return null;
    }

    /**
     * 获取编码方式
     *
     * @param
     * @return 编码方式
     * @throws Exception
     */
    public static String codeString(File file) throws Exception {
        FileInputStream fileInputStream = new FileInputStream(file);
        BufferedInputStream bin = new BufferedInputStream(fileInputStream);
        int p = (bin.read() << 8) + bin.read();
        String code = null;
        switch (p) {
            case 0xefbb:
                code = "UTF-8";
                break;
            case 0xfffe:
                code = "Unicode";
                break;
            case 0xfeff:
                code = "UTF-16BE";
                break;
            default:
                code = "GBK";
        }
        IOUtils.closeQuietly(bin);
        IOUtils.closeQuietly(fileInputStream);
        System.out.println(code);
        return code;
    }
}
